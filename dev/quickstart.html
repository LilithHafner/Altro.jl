<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · Altro</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Altro</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="quickstart.html">Getting Started</a><ul class="internal"><li><a class="tocitem" href="#.-Load-the-packages"><span>1. Load the packages</span></a></li><li><a class="tocitem" href="#.-Set-up-the-dynamics-model"><span>2. Set up the dynamics model</span></a></li><li><a class="tocitem" href="#.-Set-up-the-objective"><span>3. Set up the objective</span></a></li><li><a class="tocitem" href="#.-Add-the-constraints"><span>4. Add the constraints</span></a></li><li><a class="tocitem" href="#.-Define-the-problem"><span>5. Define the problem</span></a></li><li><a class="tocitem" href="#.-Intialize-the-solver"><span>6. Intialize the solver</span></a></li><li><a class="tocitem" href="#.-Solve-the-problem"><span>7. Solve the problem</span></a></li><li><a class="tocitem" href="#.-Post-analysis"><span>8. Post-analysis</span></a></li></ul></li><li><a class="tocitem" href="options.html">Solver Options</a></li><li><a class="tocitem" href="advanced.html">Advanced Options</a></li><li><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="quickstart.html">Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quickstart.html">Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RoboticExplorationLab/Altro.jl/blob/master/docs/src/quickstart.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h1><ul><li><a href="quickstart.html#Getting-Started">Getting Started</a></li><li class="no-marker"><ul><li><a href="quickstart.html#.-Load-the-packages">1. Load the packages</a></li><li><a href="quickstart.html#.-Set-up-the-dynamics-model">2. Set up the dynamics model</a></li><li><a href="quickstart.html#.-Set-up-the-objective">3. Set up the objective</a></li><li><a href="quickstart.html#.-Add-the-constraints">4. Add the constraints</a></li><li><a href="quickstart.html#.-Define-the-problem">5. Define the problem</a></li><li><a href="quickstart.html#.-Intialize-the-solver">6. Intialize the solver</a></li><li><a href="quickstart.html#.-Solve-the-problem">7. Solve the problem</a></li><li><a href="quickstart.html#.-Post-analysis">8. Post-analysis</a></li></ul></li></ul><p>Setting up and solving a problem with ALTRO is very straight-forward. Let&#39;s walk through an example of getting a Dubins car to drive through some circular obstacles.</p><h2 id=".-Load-the-packages"><a class="docs-heading-anchor" href="#.-Load-the-packages">1. Load the packages</a><a id=".-Load-the-packages-1"></a><a class="docs-heading-anchor-permalink" href="#.-Load-the-packages" title="Permalink"></a></h2><p>Our first step is to load the required packages. Since we need to define our dynamics model, we need <a href="https://github.com/RoboticExplorationLab/RobotDynamics.jl">RobotDynamics.jl</a>, and we need <a href="https://github.com/RoboticExplorationLab/TrajectoryOptimization.jl">TrajectoryOptimization.jl</a> to define our problem. We&#39;ll  also import <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> for  fast, allocation-free matrix methods, and the <code>LinearAlgebra</code> module. To avoid  having to type <code>TrajectoryOptimization</code> and <code>RobotDynamics</code> all the time, we also create some convenient aliases.</p><pre><code class="language-julia hljs">using Altro
using TrajectoryOptimization
using RobotDynamics
using StaticArrays, LinearAlgebra
const TO = TrajectoryOptimization
const RD = RobotDynamics</code></pre><h2 id=".-Set-up-the-dynamics-model"><a class="docs-heading-anchor" href="#.-Set-up-the-dynamics-model">2. Set up the dynamics model</a><a id=".-Set-up-the-dynamics-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-Set-up-the-dynamics-model" title="Permalink"></a></h2><p>We now define our dynamics model using RobotDynamics.jl. We define a new type <code>Car</code>  that inherits from <code>RobotDynamics.ContinuousDynamics</code>. We can store any of our model  parameters in this type. After defining the state and control dimensions and the  continuous dynamics, we&#39;re done defining our model. Integration of the dynamics and the dynamics derivatives can be done automatically.</p><pre><code class="language-julia hljs">using ForwardDiff  # needed for @autodiff
using FiniteDiff   # needed for @autodiff

RD.@autodiff struct DubinsCar &lt;: RD.ContinuousDynamics end
RD.state_dim(::DubinsCar) = 3
RD.control_dim(::DubinsCar) = 2

function RD.dynamics(::DubinsCar,x,u)
    ẋ = @SVector [u[1]*cos(x[3]),
                  u[1]*sin(x[3]),
                  u[2]]
end</code></pre><p>The code above is the minimal amount of code we need to write to define our dynamics. We can also define in-place evaluation methods and an analytic Jacobian:</p><pre><code class="language-julia hljs">function RD.dynamics!(::DubinsCar, xdot, x, u)
    xdot[1] = u[1] * cos(x[3])
    xdot[2] = u[1] * sin(x[3])
    xdot[3] = u[2]
    return nothing
end

function RD.jacobian!(::DubinsCar, J, xdot, x, u)
    J .= 0
    J[1,3] = -u[1] * sin(x[3])
    J[1,4] = cos(x[3])
    J[2,3] = u[1] * cos(x[3])
    J[2,4] = sin(x[3])
    J[3,5] = 1.0
    return nothing
end

# Specify the default method to be used when calling the dynamics
#   options are `RD.StaticReturn()` or `RD.InPlace()`
RD.default_signature(::DubinsCar) = RD.StaticReturn()

# Specify the default method for evaluating the dynamics Jacobian
#   options are `RD.ForwardAD()`, `RD.FiniteDifference()`, or `RD.UserDefined()`
RD.default_diffmethod(::DubinsCar) = RD.UserDefined()</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We use <code>RobotDynamics.@autodiff</code> to automatically define methods to evaluate  the Jacobian of our dynamics function. See the RobotDynamics documentation  for more details. Note that we have to include the FiniteDiff and ForwardDiff packages to use this method.</p></div></div><h2 id=".-Set-up-the-objective"><a class="docs-heading-anchor" href="#.-Set-up-the-objective">3. Set up the objective</a><a id=".-Set-up-the-objective-1"></a><a class="docs-heading-anchor-permalink" href="#.-Set-up-the-objective" title="Permalink"></a></h2><p>Once we&#39;ve defined the model, we can now start defining our problem. Let&#39;s start by defining the discretization:</p><pre><code class="language-julia hljs">model = DubinsCar()
dmodel = RD.DiscretizedDynamics{RD.RK4}(model)
n,m = size(model)    # get state and control dimension
N = 101              # number of time steps (knot points). Should be odd.
tf = 3.0             # total time (sec)
dt = tf / (N-1)      # time step (sec)</code></pre><p>Note that we need a discrete version of our dynamics model, which we can obtain using  the <code>RobotDynamics.DiscretizedDynamics</code> type. This type creates a  <code>RobotDynamics.DiscreteDynamics</code> type from a <code>RobotDynamics.ContinuousDynamics</code> type  using a supplied integrator. Here we use the 4th-order explicit Runge-Kutta method provided by RobotDynamics.jl.</p><p>Now we specify our initial and final conditions:</p><pre><code class="language-julia hljs">x0 = SA_F64[0,0,0]   # start at the origin
xf = SA_F64[1,2,pi]  # goal state</code></pre><p>For our objective, let&#39;s define a quadratic cost function that penalizes distance from  the goal state:</p><pre><code class="language-julia hljs">Q  = Diagonal(SA[0.1,0.1,0.01])
R  = Diagonal(SA[0.01, 0.1])
Qf = Diagonal(SA[1e2,1e2,1e3])
obj = LQRObjective(Q,R,Qf,xf,N)</code></pre><h2 id=".-Add-the-constraints"><a class="docs-heading-anchor" href="#.-Add-the-constraints">4. Add the constraints</a><a id=".-Add-the-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#.-Add-the-constraints" title="Permalink"></a></h2><p>Now let&#39;s define the constraints for our problem. We&#39;re going to bound the workspace of the robot, and add two obstacles. We start by defining a <code>ConstraintList</code>, which  is going to hold all of the constraints and make sure they&#39;re dimensions are  consistent. Here we add a goal constraint at the last time step, a workspace  constraint, and then the circular obstacle constraint.</p><pre><code class="language-julia hljs">cons = ConstraintList(n,m,N)

# Goal constraint
goal = GoalConstraint(xf)
add_constraint!(cons, goal, N)

# Workspace constraint
bnd = BoundConstraint(n,m, x_min=[-0.1,-0.1,-Inf], x_max=[5,5,Inf])
add_constraint!(cons, bnd, 1:N-1)

# Obstacle Constraint
#   Defines two circular obstacles:
#   - Position (1,1) with radius 0.2
#   - Position (2,1) with radius 0.3
obs = CircleConstraint(n, SA_F64[1,2], SA_F64[1,1], SA[0.2, 0.3])
add_constraint!(cons, bnd, 1:N-1)</code></pre><h2 id=".-Define-the-problem"><a class="docs-heading-anchor" href="#.-Define-the-problem">5. Define the problem</a><a id=".-Define-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#.-Define-the-problem" title="Permalink"></a></h2><p>With the dynamics model, discretization, objective, constraints, and initial condition defined, we&#39;re ready to define the problem, which we do with  <code>TrajectoryOptimization.Problem</code>. </p><pre><code class="language-julia hljs">prob = Problem(model, obj, x0, tf, xf=xf, constraints=cons)</code></pre><p>Initialization is key when nonlinear optimization problems with gradient-based methods.  Since this problem is pretty easy, we&#39;ll just initialize it with small random noise  on the controls and then simulate the system forward in time.</p><pre><code class="language-julia hljs">initial_controls!(prob, [@SVector rand(m) for k = 1:N-1])
rollout!(prob)   # simulate the system forward in time with the new controls</code></pre><h2 id=".-Intialize-the-solver"><a class="docs-heading-anchor" href="#.-Intialize-the-solver">6. Intialize the solver</a><a id=".-Intialize-the-solver-1"></a><a class="docs-heading-anchor-permalink" href="#.-Intialize-the-solver" title="Permalink"></a></h2><p>With the problem now defined, we&#39;re ready to start using Altro.jl (everything up to this point used only RobotDynamics.jl or TrajectoryOptimization.jl). All we need to do is create an <code>ALTROSolver</code>.</p><pre><code class="language-julia hljs">solver = ALTROSolver(prob)</code></pre><h3 id="Setting-Solver-Options"><a class="docs-heading-anchor" href="#Setting-Solver-Options">Setting Solver Options</a><a id="Setting-Solver-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Solver-Options" title="Permalink"></a></h3><p>We can set solver options via keyword arguments to the constructor, or by passing in  a <code>SolverOptions</code> type:</p><pre><code class="language-julia hljs"># Set up solver options
opts = SolverOptions()
opts.cost_tolerance = 1e-5

# Create a solver, adding in additional options
solver = ALTROSolver(prob, opts, show_summary=false)</code></pre><p>You can also use the <a href="options.html#Altro.set_options!"><code>set_options!</code></a> method on a solver once it&#39;s created.</p><h2 id=".-Solve-the-problem"><a class="docs-heading-anchor" href="#.-Solve-the-problem">7. Solve the problem</a><a id=".-Solve-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#.-Solve-the-problem" title="Permalink"></a></h2><p>With the solver initialized, we can now solve the problem with a simple call to  <code>solve!</code>:</p><pre><code class="language-julia hljs">solve!(solver)</code></pre><h2 id=".-Post-analysis"><a class="docs-heading-anchor" href="#.-Post-analysis">8. Post-analysis</a><a id=".-Post-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#.-Post-analysis" title="Permalink"></a></h2><h3 id="Checking-solve-status"><a class="docs-heading-anchor" href="#Checking-solve-status">Checking solve status</a><a id="Checking-solve-status-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-solve-status" title="Permalink"></a></h3><p>Once the solve is complete, we can look at a few things. The first is to check if the solve is successful:</p><pre><code class="language-julia hljs">status(solver)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SOLVE_SUCCEEDED::TerminationStatus = 2</code></pre><p>We can also extract some more information</p><pre><code class="language-julia hljs">println(&quot;Number of iterations: &quot;, iterations(solver))
println(&quot;Final cost: &quot;, cost(solver))
println(&quot;Final constraint satisfaction: &quot;, max_violation(solver))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number of iterations: 15
Final cost: 12.480778190315517
Final constraint satisfaction: 9.890404051304813e-10</code></pre><h3 id="Extracting-the-solution"><a class="docs-heading-anchor" href="#Extracting-the-solution">Extracting the solution</a><a id="Extracting-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-solution" title="Permalink"></a></h3><p>We can extract the state and control trajectories, which are returned as vectors of <code>SVector</code>s:</p><pre><code class="language-julia hljs">X = states(solver)     # alternatively states(prob)
U = controls(solver)   # alternatively controls(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{StaticArrays.SVector{2, Float64}}:
 [0.10408302208234128, 2.5451711328978885]
 [0.7789573376495889, 2.518515596296924]
 [1.3567922649581439, 2.4688262763897826]
 [1.838793744040298, 2.4020103684781264]
 [2.2294919689729085, 2.3233261896371555]
 [2.535779163638351, 2.237253292839993]
 [2.766007550074229, 2.1474552095184802]
 [2.929222530458894, 2.05681172209296]
 [3.034563692096202, 1.967495818198488]
 [3.0908342107730546, 1.881073573968168]
 ⋮
 [0.10448425071528551, 0.7290808662621812]
 [0.11049070103073053, 0.7283195318362217]
 [0.1173845733638137, 0.7276105683753835]
 [0.12523472114668266, 0.7269519936998429]
 [0.13411707870043765, 0.7263417120658394]
 [0.14411524469069364, 0.7257775059517194]
 [0.1553211220252285, 0.7252570287084238]
 [0.1678356188089972, 0.7247777982301813]
 [0.1817694147293027, 0.7243371924880037]</code></pre><p>If you prefer to work with matrices, you can convert them easily:</p><pre><code class="language-julia hljs">Xm = hcat(Vector.(X)...)  # convert to normal Vector before concatenating so it&#39;s fast
Um = hcat(Vector.(U)...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×100 Matrix{Float64}:
 0.104083  0.778957  1.35679  1.83879  …  0.155321  0.167836  0.181769
 2.54517   2.51852   2.46883  2.40201     0.725257  0.724778  0.724337</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Converting a matrix into a vector of vectors is also very easy:</p><pre><code class="language-julia hljs">X = [col for col in eachcol(Xm)]</code></pre><p>Or if you want static vectors:</p><pre><code class="language-julia hljs">X = [SVector{n}(col) for col in eachcol(Xm)]</code></pre></div></div><h3 id="Extracting-the-final-feedback-gains"><a class="docs-heading-anchor" href="#Extracting-the-final-feedback-gains">Extracting the final feedback gains</a><a id="Extracting-the-final-feedback-gains-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-the-final-feedback-gains" title="Permalink"></a></h3><p>Since ALTRO uses iLQR, the solver computes a locally optimal linear feedback policy which can be useful for tracking purposes. We can extract it from the internal  <code>Altro.iLQRSolver</code>:</p><pre><code class="language-julia hljs">ilqr = Altro.get_ilqr(solver)
K = ilqr.K  # feedback gain matrices
d = ilqr.d  # feedforward gains. Should be small.</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{SubArray{Float64, 1, Matrix{Float64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:
 [1.846125226267802e-5, 5.427385581630193e-5]
 [2.5942786531631744e-6, 3.163589387114192e-5]
 [-8.526583607315221e-6, 1.2725978068324694e-5]
 [-1.54845675179529e-5, -2.821528105996946e-6]
 [-1.894943851300353e-5, -1.5420710535127397e-5]
 [-1.960184976791704e-5, -2.548891729689773e-5]
 [-1.807843394040116e-5, -3.341753204109055e-5]
 [-1.4939285118577435e-5, -3.9556221406418595e-5]
 [-1.0654540244404678e-5, -4.4207177789173675e-5]
 [-5.604568196773813e-6, -4.762587258810553e-5]
 ⋮
 [-2.775757113295284e-6, -1.579449880494726e-6]
 [-3.6210408165175617e-6, -1.3927807846409028e-6]
 [-4.4871316044443125e-6, -1.1957678655922449e-6]
 [-5.389495818408288e-6, -9.868246828583334e-7]
 [-6.291617404559907e-6, -7.65331913728081e-7]
 [-6.96213881396233e-6, -5.350440752877129e-7]
 [-6.629238904425522e-6, -3.1325107842097995e-7]
 [-3.928553233474942e-6, -1.356474342507319e-7]
 [8.553970817741724e-7, -1.380384429250657e-9]</code></pre><h3 id="Additional-solver-stats"><a class="docs-heading-anchor" href="#Additional-solver-stats">Additional solver stats</a><a id="Additional-solver-stats-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-solver-stats" title="Permalink"></a></h3><p>We can extract more detailed information on the solve from <a href="options.html#Altro.SolverStats"><code>SolverStats</code></a></p><pre><code class="language-julia hljs">Altro.stats(solver)</code></pre><p>The most relevant fields are the <code>cost</code>, <code>c_max</code>, and <code>gradient</code>. These give the history of these values for each iteration. The <code>iteration_outer</code> can also be helpful to know which iterations were outer loop (augmented Lagrangian)  iterations. The <code>tsolve</code> field gives the total solve time in milliseconds.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="options.html">Solver Options »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Sunday 10 April 2022 15:37">Sunday 10 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
