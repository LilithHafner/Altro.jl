var documenterSearchIndex = {"docs":
[{"location":"api.html#Altro.jl-API","page":"API","title":"Altro.jl API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"CurrentModule = Altro","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html","page":"API","title":"API","text":"This page provides the docstrings for the most common methods that the user may work with.","category":"page"},{"location":"api.html#Solvers","page":"API","title":"Solvers","text":"","category":"section"},{"location":"api.html#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"ALTROSolver\nALSolver\niLQRSolver\nProjectedNewtonSolver","category":"page"},{"location":"api.html#Altro.ALTROSolver","page":"API","title":"Altro.ALTROSolver","text":"ALTROSolver\n\nAugmented Lagrangian Trajectory Optimizer (ALTRO) is a solver developed by the Robotic Exploration Lab at Stanford University.     The solver is special-cased to solve Markov Decision Processes by leveraging the internal problem structure.\n\nALTRO consists of two \"phases\":\n\nAL-iLQR: iLQR is used with an Augmented Lagrangian framework to solve the problem quickly to rough constraint satisfaction\nProjected Newton: A collocation-flavored active-set solver projects the solution from AL-iLQR onto the feasible subspace to achieve machine-precision constraint satisfaction.\n\nConstructor\n\nALTROSolver(prob::Problem, opts::SolverOptions; [infeasible, R_inf, kwarg_opts...])\n\nThe infeasible keyword is a boolean flag that specifies whether the solver should augment the controls to make it artificially fully actuated, allowing state initialization. The R_inf is the weight on these augmented controls. Any solver options can be passed as additional keyword arguments and will be set in the solver.\n\nGetters\n\nget_model\nget_objective\nget_constraints\nAltro.get_ilqr\nTO.get_initial_state\n\nOther methods\n\nBase.size: returns (n,m,N)\nTO.is_constrained\n\n\n\n\n\n","category":"type"},{"location":"api.html#Altro.ALSolver","page":"API","title":"Altro.ALSolver","text":"struct ALSolver <: ConstrainedSolver{T}\n\nAugmented Lagrangian (AL) is a standard tool for constrained optimization. For a trajectory optimization problem of the form:\n\nbeginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) leq 0 \n                                  h_k(x_ku_k) = 0\nendaligned\n\nAL methods form the following augmented Lagrangian function:\n\nbeginaligned\n    ell_f(x_N) + λ_N^T c_N(x_N) + c_N(x_N)^T I_mu_N c_N(x_N) \n            + sum_k=0^N-1 ell_k(x_ku_kdt) + λ_k^T c_k(x_ku_k) + c_k(x_ku_k)^T I_mu_k c_k(x_ku_k)\nendaligned\n\nThis function is then minimized with respect to the primal variables using any unconstrained minimization solver (e.g. iLQR).     After a local minima is found, the AL method updates the Lagrange multipliers λ and the penalty terms μ and repeats the unconstrained minimization.     AL methods have superlinear convergence as long as the penalty term μ is updated each iteration.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Altro.iLQRSolver","page":"API","title":"Altro.iLQRSolver","text":"iLQRSolver\n\nA fast solver for unconstrained trajectory optimization that uses a Riccati recursion to solve for a local feedback controller around the current trajectory, and then  simulates the system forward using the derived feedback control law.\n\nConstructor\n\nAltro.iLQRSolver(prob, opts; kwarg_opts...)\n\nWith the following keyword arguments:\n\nuse_static Pass Val(true) to use StaticArrays as the internal storage for the trajectories.\n\nThis will, by default, then use RobotDynamics.StaticReturn() methods for the dynamics.\n\nAll other keyword arguments are interpreted as solver options passed to set_options!.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Altro.ProjectedNewtonSolver","page":"API","title":"Altro.ProjectedNewtonSolver","text":"ProjectedNewtonSolver\n\nProjected Newton Solver Direct method developed by the REx Lab at Stanford University Achieves machine-level constraint satisfaction by projecting onto the feasible subspace.     It can also take a full Newton step by solving the KKT system. This solver is to be used exlusively for solutions that are close to the optimal solution.     It is intended to be used as a \"solution polishing\" method for augmented Lagrangian methods.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"backwardpass!\nforwardpass!\nrecord_iteration!","category":"page"},{"location":"api.html#Altro.backwardpass!","page":"API","title":"Altro.backwardpass!","text":"backwardpass!(::iLQRSolver)\n\nCompute the backwardpass of iLQR, which forms a local quadratic approximation of the  cost-to-go and constructs a local affine control policy about the current trajectory using time-varying LQR. The expansions of the objective function and dynamics  should already be computed before calling this function.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Altro.forwardpass!","page":"API","title":"Altro.forwardpass!","text":"forwardpass!(solver, J_prev)\n\nThe \"line search\" of the iLQR algorithm. The system is simulated forward using the local affine feedback control policy computed by the backward pass, scaling the  feedforward terms until satisfactory progress is made.\n\nReturns the new cost after finding a line search step size that makes sufficient progress. The new trajectories are stored in solver.Z̄, and are copied in the main solve  step.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Altro.record_iteration!","page":"API","title":"Altro.record_iteration!","text":"record_iteration!(solver, J, dJ, grad)\n\nRecords the information on the current iteration of the solver, storing all of the  data in the SolverStats struct stored in the solver.\n\n\n\n\n\n","category":"function"},{"location":"quickstart.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"CurrentModule = Altro","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Pages = [\"quickstart.md\"]","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Setting up and solving a problem with ALTRO is very straight-forward. Let's walk through an example of getting a Dubins car to drive through some circular obstacles.","category":"page"},{"location":"quickstart.html#.-Load-the-packages","page":"Getting Started","title":"1. Load the packages","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Our first step is to load the required packages. Since we need to define our dynamics model, we need RobotDynamics.jl, and we need TrajectoryOptimization.jl to define our problem. We'll  also import StaticArrays.jl for  fast, allocation-free matrix methods, and the LinearAlgebra module. To avoid  having to type TrajectoryOptimization and RobotDynamics all the time, we also create some convenient aliases.","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"using Altro\nusing TrajectoryOptimization\nusing RobotDynamics\nusing StaticArrays, LinearAlgebra\nconst TO = TrajectoryOptimization\nconst RD = RobotDynamics\nnothing # hide","category":"page"},{"location":"quickstart.html#.-Set-up-the-dynamics-model","page":"Getting Started","title":"2. Set up the dynamics model","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"We now define our dynamics model using RobotDynamics.jl. We define a new type Car  that inherits from RobotDynamics.ContinuousDynamics. We can store any of our model  parameters in this type. After defining the state and control dimensions and the  continuous dynamics, we're done defining our model. Integration of the dynamics and the dynamics derivatives can be done automatically.","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"using ForwardDiff  # needed for @autodiff\nusing FiniteDiff   # needed for @autodiff\n\nRD.@autodiff struct DubinsCar <: RD.ContinuousDynamics end\nRD.state_dim(::DubinsCar) = 3\nRD.control_dim(::DubinsCar) = 2\n\nfunction RD.dynamics(::DubinsCar,x,u)\n    ẋ = @SVector [u[1]*cos(x[3]),\n                  u[1]*sin(x[3]),\n                  u[2]]\nend","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"The code above is the minimal amount of code we need to write to define our dynamics. We can also define in-place evaluation methods and an analytic Jacobian:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"function RD.dynamics!(::DubinsCar, xdot, x, u)\n    xdot[1] = u[1] * cos(x[3])\n    xdot[2] = u[1] * sin(x[3])\n    xdot[3] = u[2] \n    return nothing\nend\n\nfunction RD.jacobian!(::DubinsCar, J, xdot, x, u)\n    J .= 0\n    J[1,3] = -u[1] * sin(x[3])\n    J[1,4] = cos(x[3])\n    J[2,3] = u[1] * cos(x[3])\n    J[2,4] = sin(x[3])\n    J[3,5] = 1.0\n    return nothing\nend\n\n# Specify the default method to be used when calling the dynamics\n#   options are `RD.StaticReturn()` or `RD.InPlace()`\nRD.default_signature(::DubinsCar) = RD.StaticReturn()\n\n# Specify the default method for evaluating the dynamics Jacobian\n#   options are `RD.ForwardAD()`, `RD.FiniteDifference()`, or `RD.UserDefined()`\nRD.default_diffmethod(::DubinsCar) = RD.UserDefined()","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nWe use RobotDynamics.@autodiff to automatically define methods to evaluate  the Jacobian of our dynamics function. See the RobotDynamics documentation  for more details. Note that we have to include the FiniteDiff and ForwardDiff packages to use this method.","category":"page"},{"location":"quickstart.html#.-Set-up-the-objective","page":"Getting Started","title":"3. Set up the objective","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Once we've defined the model, we can now start defining our problem. Let's start by defining the discretization:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"model = DubinsCar()\ndmodel = RD.DiscretizedDynamics{RD.RK4}(model)\nn,m = size(model)    # get state and control dimension\nN = 101              # number of time steps (knot points). Should be odd.\ntf = 3.0             # total time (sec)\ndt = tf / (N-1)      # time step (sec)\nnothing  # hide","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Note that we need a discrete version of our dynamics model, which we can obtain using  the RobotDynamics.DiscretizedDynamics type. This type creates a  RobotDynamics.DiscreteDynamics type from a RobotDynamics.ContinuousDynamics type  using a supplied integrator. Here we use the 4th-order explicit Runge-Kutta method provided by RobotDynamics.jl.","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Now we specify our initial and final conditions:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"x0 = SA_F64[0,0,0]   # start at the origin\nxf = SA_F64[1,2,pi]  # goal state\nnothing  # hide","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"For our objective, let's define a quadratic cost function that penalizes distance from  the goal state:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Q  = Diagonal(SA[0.1,0.1,0.01])\nR  = Diagonal(SA[0.01, 0.1])\nQf = Diagonal(SA[1e2,1e2,1e3])\nobj = LQRObjective(Q,R,Qf,xf,N)\nnothing # hide","category":"page"},{"location":"quickstart.html#.-Add-the-constraints","page":"Getting Started","title":"4. Add the constraints","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Now let's define the constraints for our problem. We're going to bound the workspace of the robot, and add two obstacles. We start by defining a ConstraintList, which  is going to hold all of the constraints and make sure they're dimensions are  consistent. Here we add a goal constraint at the last time step, a workspace  constraint, and then the circular obstacle constraint.","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"cons = ConstraintList(n,m,N)\n\n# Goal constraint\ngoal = GoalConstraint(xf)\nadd_constraint!(cons, goal, N)\n\n# Workspace constraint\nbnd = BoundConstraint(n,m, x_min=[-0.1,-0.1,-Inf], x_max=[5,5,Inf])\nadd_constraint!(cons, bnd, 1:N-1)\n\n# Obstacle Constraint\n#   Defines two circular obstacles:\n#   - Position (1,1) with radius 0.2\n#   - Position (2,1) with radius 0.3\nobs = CircleConstraint(n, SA_F64[1,2], SA_F64[1,1], SA[0.2, 0.3])\nadd_constraint!(cons, bnd, 1:N-1)\nnothing # hide","category":"page"},{"location":"quickstart.html#.-Define-the-problem","page":"Getting Started","title":"5. Define the problem","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"With the dynamics model, discretization, objective, constraints, and initial condition defined, we're ready to define the problem, which we do with  TrajectoryOptimization.Problem. ","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"prob = Problem(model, obj, x0, tf, xf=xf, constraints=cons)\nnothing # hide","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Initialization is key when nonlinear optimization problems with gradient-based methods.  Since this problem is pretty easy, we'll just initialize it with small random noise  on the controls and then simulate the system forward in time.","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"initial_controls!(prob, [@SVector rand(m) for k = 1:N-1])\nrollout!(prob)   # simulate the system forward in time with the new controls","category":"page"},{"location":"quickstart.html#.-Intialize-the-solver","page":"Getting Started","title":"6. Intialize the solver","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"With the problem now defined, we're ready to start using Altro.jl (everything up to this point used only RobotDynamics.jl or TrajectoryOptimization.jl). All we need to do is create an ALTROSolver.","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"solver = ALTROSolver(prob)\nnothing # hide","category":"page"},{"location":"quickstart.html#Setting-Solver-Options","page":"Getting Started","title":"Setting Solver Options","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"We can set solver options via keyword arguments to the constructor, or by passing in  a SolverOptions type:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"# Set up solver options\nopts = SolverOptions()\nopts.cost_tolerance = 1e-5\n\n# Create a solver, adding in additional options\nsolver = ALTROSolver(prob, opts, show_summary=false)\nnothing # hide","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"You can also use the set_options! method on a solver once it's created.","category":"page"},{"location":"quickstart.html#.-Solve-the-problem","page":"Getting Started","title":"7. Solve the problem","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"With the solver initialized, we can now solve the problem with a simple call to  solve!:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"solve!(solver)\nnothing # hide","category":"page"},{"location":"quickstart.html#.-Post-analysis","page":"Getting Started","title":"8. Post-analysis","text":"","category":"section"},{"location":"quickstart.html#Checking-solve-status","page":"Getting Started","title":"Checking solve status","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Once the solve is complete, we can look at a few things. The first is to check if the solve is successful:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"status(solver)","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"We can also extract some more information","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"println(\"Number of iterations: \", iterations(solver))\nprintln(\"Final cost: \", cost(solver))\nprintln(\"Final constraint satisfaction: \", max_violation(solver))","category":"page"},{"location":"quickstart.html#Extracting-the-solution","page":"Getting Started","title":"Extracting the solution","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"We can extract the state and control trajectories, which are returned as vectors of SVectors:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"X = states(solver)     # alternatively states(prob)\nU = controls(solver)   # alternatively controls(prob)","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"If you prefer to work with matrices, you can convert them easily:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Xm = hcat(Vector.(X)...)  # convert to normal Vector before concatenating so it's fast\nUm = hcat(Vector.(U)...)","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nConverting a matrix into a vector of vectors is also very easy:X = [col for col in eachcol(Xm)]Or if you want static vectors:X = [SVector{n}(col) for col in eachcol(Xm)]","category":"page"},{"location":"quickstart.html#Extracting-the-final-feedback-gains","page":"Getting Started","title":"Extracting the final feedback gains","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Since ALTRO uses iLQR, the solver computes a locally optimal linear feedback policy which can be useful for tracking purposes. We can extract it from the internal  Altro.iLQRSolver:","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"ilqr = Altro.get_ilqr(solver)\nK = ilqr.K  # feedback gain matrices\nd = ilqr.d  # feedforward gains. Should be small.","category":"page"},{"location":"quickstart.html#Additional-solver-stats","page":"Getting Started","title":"Additional solver stats","text":"","category":"section"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"We can extract more detailed information on the solve from SolverStats","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"Altro.stats(solver)\nnothing  # hide","category":"page"},{"location":"quickstart.html","page":"Getting Started","title":"Getting Started","text":"The most relevant fields are the cost, c_max, and gradient. These give the history of these values for each iteration. The iteration_outer can also be helpful to know which iterations were outer loop (augmented Lagrangian)  iterations. The tsolve field gives the total solve time in milliseconds.","category":"page"},{"location":"advanced.html#Advanced-Options","page":"Advanced Options","title":"Advanced Options","text":"","category":"section"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"CurrentModule = Altro","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"Pages = [\"advanced.md\"]","category":"page"},{"location":"advanced.html#Infeasible-Start","page":"Advanced Options","title":"Infeasible Start","text":"","category":"section"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"Standard indirect methods such as iLQR cannot be initialized with a state trajectory since they are always dynamically feasible. However, for some problems an initial  state trajectory is very informative and easy to generate, while supplying an  initial guess for the controls is extremely difficult. For example, consider a  quadrotor flying around some obstacles. Guessing a good path, or even the velocities, would be pretty easy, but supplying the control sequence to generate that path  is nearly as hard as just solving the entire trajectory optimization problem. ","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"ALTRO allows for \"infeasible\" starts by augmenting the discrete dynamics so that  they become fully actuated, i.e. for any state we can provide a control that will acheive it. This increases the size of the control dimension by n, the number of states in the original problem, so the problem becomes more expensive to solve.","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"We specify that we want an infeasible start by passing the infeasible flag to  the ALTRO constructor:","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"using Altro\nprob,opts = Problems.DubinsCar(:escape)\nsolver = ALTROSolver(prob, opts, infeasible=true, R_inf=0.1)\nnothing  # hide","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"where R_inf is the norm of the regularizer on the additional controls. Notice how the new control dimension is 5, since the original control and state dimensions were 2 and 3.","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"The initial state trajectory can be provided using one of","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"initial_states!(solver, X0)\ninitial_trajectory!(solver, Z0)","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"where X0::Union{SVector, Matrix, Vector{<:StaticVector}} and  Z0::SampledTrajectory. ","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"InfeasibleModel\nInfeasibleConstraint\ninfeasible_trajectory","category":"page"},{"location":"advanced.html#Altro.InfeasibleModel","page":"Advanced Options","title":"Altro.InfeasibleModel","text":"InfeasibleModel\n\nAn infeasible model is an augmented dynamics model that makes the system artifically fully actuated by augmenting the control vector with n additional controls. The dynamics are handled explicitly in discrete time:\n\nx_k+1 = f(x_ku_kdt) + w_k\n\nwhere w_k are the additional n-dimensional controls. In practice, these are constrained to be zero by the end of the solve.\n\nConstructors\n\nInfeasibleModel(model::AbstractModel)\n\n\n\n\n\n","category":"type"},{"location":"advanced.html#Altro.InfeasibleConstraint","page":"Advanced Options","title":"Altro.InfeasibleConstraint","text":"InfeasibleConstraint\n\nConstraints additional infeasible controls to be zero Constructorsjulia InfeasibleConstraint(model::InfeasibleModel) InfeasibleConstraint(n,m)``\n\n\n\n\n\n","category":"type"},{"location":"advanced.html#Altro.infeasible_trajectory","page":"Advanced Options","title":"Altro.infeasible_trajectory","text":"Calculate a dynamically feasible initial trajectory for an infeasible problem, given a desired trajectory\n\n\n\n\n\n","category":"function"},{"location":"advanced.html#Using-Implicit-Integrators","page":"Advanced Options","title":"Using Implicit Integrators","text":"","category":"section"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"By leveraging the functionality of RobotDynamics.jl, Altro can easily solve problems  using implicit integrators like implicit midpoint, which as a symplectic integrator  has energy-conserving behaviors and also preserves any implicit norms in the dynamics (such as the norm on a quaternion representing rotations). The following example  shows how to use an implicit integrator:","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"using RobotZoo: Cartpole\nusing RobotDynamics\nusing TrajectoryOptimization\nusing Altro\nusing LinearAlgebra\nconst RD = RobotDynamics\n\nmodel = Cartpole()\ndmodel = RD.DiscretizedDynamics{RD.ImplicitMidpoint}(model)\n\n# Temporary \"hack\" to make sure it doesn't try to use the `UserDefined` method\nRD.default_diffmethod(::Cartpole) = RD.ForwardAD()\n\ntf = 2.0\nN = 51\nn,m = RD.dims(model)\nx0 = [0,0,0,0.]\nxf = [0,pi,0,0]\n\nQ = Diagonal(fill(1.0, n))\nR = Diagonal(fill(0.1, m))\nQf = Q*(N-1) \nobj = LQRObjective(Q,R,Qf,xf,N)\n\nprob = Problem(dmodel, obj, x0, tf)\n\nsolver = ALTROSolver(\n    prob, \n    dynamics_diffmethod=RD.ImplicitFunctionTheorem(RD.ForwardAD())\n)\nnothing  # hide","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"The key here is to specify the solver option dynamics_diffmethod to be RobotDynamics.ImplicitFunctionTheorem() which takes another RobotDynamics.DiffMethod as an argument, which specified how the Jacobians of the dynamics residual should be  computed. The implicit function theorem then uses the partial derivatives to compute  the Jacobians with respect to the next state, which are the Jacobians requried by  algorithms like iLQR.","category":"page"},{"location":"advanced.html#Disabling-Octavian","page":"Advanced Options","title":"Disabling Octavian","text":"","category":"section"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"By default, Altro.jl uses  Octavian.jl for matrix  multiplication. This typically yields very good runtime performance but can take a  while to compile the first time. If you want to disable the use of Octavian,  set the environment variable ALTRO_USE_OCTAVIAN = false prior to using Altro. If Altro has already precompiled, you'll need to delete the compiled cache using","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"rm -rf ~/.julia/compiled/v1.x/Altro/*","category":"page"},{"location":"advanced.html","page":"Advanced Options","title":"Advanced Options","text":"and then when you enter using Altro in the Julia REPL you should see it print a  message that it's precompiling. You can check to see if Altro is using Octavian  by checking the Altro.USE_OCTAVIAN variable in the Altro module.","category":"page"},{"location":"options.html#Solver-Options","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"CurrentModule = Altro","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"Pages = [\"options.md\"]","category":"page"},{"location":"options.html#Solver-Statistics","page":"Solver Options","title":"Solver Statistics","text":"","category":"section"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"ALTRO logs intermediate values during the course of the solve. These values are all stored in the SolverStats type, accessible via solver.stats or Altro.stats(solver). This currently stores the following information:","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"Field Description\niterations Total number of iterations\niterations_outer Number of outer loop (Augmented Lagrangian) iterations\niterations_pn Number of projected newton iterations\niteration Vector of iteration number\niteration_outer Vector of outer loop iteration number\ncost Vector of costs\ndJ Change in cost\nc_max Maximum constrained violation\ngradient Approximation of dual optimality residual (2-norm of gradient of the Lagrangian)\npenalty_max Maximum penalty parameter","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"The other fields are used interally by the solver and not important to the end user.","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"The vector fields of the SolverStats type can be converted to a dictionary via Dict(stats::SolverStats), which can then be cast into a tabular format such as DataFrame from DataFrames.jl.","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"SolverStats","category":"page"},{"location":"options.html#Altro.SolverStats","page":"Solver Options","title":"Altro.SolverStats","text":"SolverStats\n\nStruct containing key statistics collected during the solve, such as histories of  the cost and constraint violations by time step, number of iterations, solve time, etc.\n\n\n\n\n\n","category":"type"},{"location":"options.html#Solver-Options-2","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"Like any nonlinear programming solver, ALTRO comes with a host of solver options. While the default values yield good/acceptable performance on many problem, extra performance can always be gained by tuning these parameters. In practice, there are only a few parameters that need to be tuned. See the AL-iLQR Tutorial for more details.","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"The ALTRO solver is actually a composition of several different solvers with their own options. Early versions of Altro.jl required the user to manipulate a rather confusing heirarchy of solver options. Newer versions of Altro.jl provide a single options struct that dramatically simplifies setting and working with the solver parameters.","category":"page"},{"location":"options.html#Setting-Solver-Options","page":"Solver Options","title":"Setting Solver Options","text":"","category":"section"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"Solver options can be specified when the solver is instantiated or afterwards using  the set_options! command. If we have a previously constructed Problem, this looks like","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"solver = ALTROSolver(prob, verbose=1, constraint_tolerance=1e-3, square_root=true)","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"Alternatively, solver options can be set using the set_options! command after the solver has been instantiated:","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"set_options!(solver, reset_duals=true, penalty_initial=100, penalty_scaling=50)","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"set_options!","category":"page"},{"location":"options.html#Altro.set_options!","page":"Solver Options","title":"Altro.set_options!","text":"set_options!(opts::AbstractSolverOptions; kwargs...)\nset_options!(solver::AbstractSolver; opts...)\n\nSet solver options via keyword arguments, supporting either solvers or solver option types directly. Will set any and all options that match the provided arguments. For  example, set_options!(solver::ALTROSolver, constraint_tolerance=1e-4) will set the constraint tolerance option in the ALTRO, Augmented Lagrangian, and Project Newton  solvers.\n\nThe only exeption is the verbose setting, which always accepts a boolean, while ALTRO and Augmented Lagrangian solvers accept integers 0-2, with 1 providing output for the outer AL iterations but not the iLQR iterations.\n\n\n\n\n\n","category":"function"},{"location":"options.html#Querying-Solver-Options","page":"Solver Options","title":"Querying Solver Options","text":"","category":"section"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"The options struct for the ALTROSolver can be directly accessed via solver.opts or Altro.options(solver). Options can be directly set or retrieved from this mutable struct.","category":"page"},{"location":"options.html#List-of-Options","page":"Solver Options","title":"List of Options","text":"","category":"section"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"For convenience, we provide a list of options in the ALTRO solver, along with a brief description:","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"Option Description Importance Default\nconstraint_tolerance All constraint violations must be below this value. High 1e-6\ncost_tolerance The difference in costs between subsequent iterations must be below this value. High 1e-4\ncost_tolerance_intermediate Cost tolerance for intermediate iLQR solves. Can speed up convergence by increase to 10-100x the cost_tolerance. Med 1e-4\ngradient_tolerance Tolerance for 2-norm of primal optimality residual. Low 1\ngradient_tolerance_intermediate Primal optimality residual tolerance for intermediate solve. Low 10\niterations_inner Max iLQR iterations per iLQR solve. Med 300\ndJ_counter_limit Max number of times iLQR can fail to make progress before exiting. Low 10\nsquare_root Enable the square root backward pass for improved numerical conditioning (WIP). Med false\nline_search_lower_bound Lower bound for Armijo line search. Low 1e-8\nline_search_upper_bound Upper bound for Armijo line search. Low 10.0\niterations_linesearch Max number of backtracking steps in iLQR line search Low 20\nmax_cost_value Maximum cost value. Will terminate solve if cost exeeds this limit. Low 1e8\nmax_state_value Maximum value of any state. Will terminate solve if any state exeeds this limit. Low 1e8\nmax_control_value Maximum value of any control. Will terminate solve if any control exeeds this limit. Low 1e8\nstatic_bp Enable the static backward pass. Only advisable for state + control dimensions < 20. Turn off if compile time is exessive. Low true\nsave_S Save the intermediate cost-to-go expansions in the iLQR backward pass. Low false\nbp_reg Enable iLQR backward pass regularization (WIP). Med false\nbp_reg_initial Initial backward pass regularization. Low 0.0\nbp_reg_increase_factor Multiplicative factor by which the regularization is increased. Low 1.6\nbp_reg_max Maximum regularization. Low 1e8\nbp_reg_min Minimum regularization. Low 1e-8\nbp_reg_fp Amount of regularization added when foward pass fails Low 10.0\npenalty_initial Initial penalty term on all constraints. Set low if the unconstrained solution is a good approximate solution to the constrained problem, and high if the initial guess provided is a good esimate. If NaN uses values in each constraint param, which defaults to 1.0. Very High NaN\npenalty_scaling Multiplicative factor by which the penalty is increased each outer loop iteration. High values can speed up convergence but quickly lead to poor numerical conditioning on difficult problems. Start with small values and then increase.If NaN defaults to 10 in the per-constraint parameter. Very High NaN\niterations_outer Max number of outer loop (Augmented Lagrangian) iterations. Med 30\nverbose_pn Turn on printing in the projected newton solver. Low false\nn_steps Maximum number of projected newton steps. Low 2\nprojected_newton_tolerance Constraint tolerance at which the solver will exit the Augmented Lagrangian solve and start the projected newton solve. Typically sqrt(constraint_tolerance) High 1e-3\nactive_set_tolerance_pn Tolerance for the active constraints during the projected newton solve. Includes some barely satisfied constraints into the active set. Can fix singularity issues during projected newton solve. Med 1e-3\nmultiplier_projected Enable updating the dual variables during the projected newton solve. Also provides a calculation of the optimality residual in the stats output. Low true\nρ_chol Regularization on the projected newton Cholesky solve. Med 1e-2\nρ_primal Regularization on the primal variables during the projected newton solve. Required if cost Hessian is positive-semi-definite. Low 1e-8\nρ_dual Regularization on the dual variables during the multiplier projection step. Low 1e-8\nr_threshold Improvement ratio threshold for projected newton solve. If the ratio of constraint violations between subsequent steps is less than this value, it will update the cost and constraint expansions Low 1.1\nprojected_newton Enable projected newton solve. If enabled, projected_newton_solve is used as the constraint_tolerance for the AL-iLQR solve. Projected newton solve is still a WIP and not very robust. High true\niterations Max number of total iterations (iLQR + projected newton). Med 1000\nverbose Controls output during solve. 0 is zero output, 1 outputs AL iterations, and 2 outputs both AL and iLQR iterations Low 0","category":"page"},{"location":"options.html","page":"Solver Options","title":"Solver Options","text":"SolverOptions","category":"page"},{"location":"options.html#Altro.SolverOptions","page":"Solver Options","title":"Altro.SolverOptions","text":"SolverOptions\n\nStruct containing all of the options for the ALTRO solver.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Altro.jl-Documention","page":"Introduction","title":"Altro.jl Documention","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule = Altro","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Documentation for Altro.jl","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\"]","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ALTRO (Augmented Lagrangian TRajectory Optimizer) is a fast solver for solving  nonlinear, constrained trajectory optimization problems of the form:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginaligned\n  min_x_0Nu_0N-1 quad  ell_f(x_N) + sum_k=0^N-1 ell_k(x_k u_k dt) \n  textrmst            quad  x_k+1 = f(x_k u_k) \n                                  g_k(x_ku_k) in mathcalK \n                                  h_k(x_ku_k) = 0\nendaligned","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where mathcalK is either the negative orthant or the second-order cone.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ALTRO uses iterative LQR (iLQR) as the primary solver, which is used to generate  locally-optimal linear feedback policies and satisfy the nonlinear dynamics  constraints. Generic stage-wise state and control constraints are handled using an augmented Lagrangian. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Once the augmented Lagrangian solver has converged to coarse tolerances, ALTRO can switch to an active-set projected Newton phase that provides fast convergence to tight constraint satisfaction.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ALTRO has demonstrated state-of-the-art performance for convex conic MPC problems,  beating SOCP solvers such as Mosek, ECOS, and SCS. For quadratic MPC problems,  ALTRO has performance on-par or better than OSQP. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"ALTRO builds off the interfaces provided by TrajectoryOptimization.jl and  RobotDynamics.jl. Please see the documentation for those packages for a more in-depth treatment  of defining dynamics models and setting up trajectory optimization problems.  The purpose of this documentation is to provide insight into the ALTRO  algorithm, it's Julia implementation, and the options this solver provides.","category":"page"},{"location":"index.html#Key-Features","page":"Introduction","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"State-of-the-art performance for both convex (linear dynamics) and nonlinear trajectory optimization problems\nConvenient interface for dynamics and problem definition via  TrajectoryOptimization.jl and RobotDynamics.jl.\nSupports generic nonlinear state and control constraints at each time step.\nSupports second-order-cone programs (SOCPs).\nAllows initialization of both state and control trajectories.\nSupports integration up to 4th-order Runge-Kutta methods. Higher-order methods are possible but not yet implemented.\nSupports implicit integration schemes such as implicit midpoint.\nSupports optimization on the space of 3D rotations.\nProvides convenient methods for warm-starting MPC problems.\nProvides efficient methods for auto-differentiation of costs, constraints, and dynamics via ForwardDiff.jl and ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"FiniteDiff.jl.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Altro.jl can be installed via the Julia package manager. Within the Julia REPL:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"] # activate the package manager\n(v1.5) pkg> add Altro ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A specific version can be specified using","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> add Altro@0.5","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Or you can check out the main branch with","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> add Altro#main","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Lastly, if you want to clone the repo into your .julia/dev/ directory for development, you can use","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(v1.5) pkg> dev Altro ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This will automatically add all package dependencies (see Project.toml). If you want to explicitly use any of these dependencies (such as RobotDynamics.jl),  you'll need to individually add those packages to your environment via the package manager.","category":"page"}]
}
